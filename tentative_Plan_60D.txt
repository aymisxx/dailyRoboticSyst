dailyRoboticSyst: 60 Day Tentative Curriculum

=============================================

PHASE 0 Math + Python Core (Days 1–5)
-------------------------------------

We can’t control what we can’t model.
We can’t model what we can’t compute.

Day 1 — Linear algebra for systems
- Vectors as states
- Matrices as dynamics
- Eigenvalues as behavior indicators
- Python: NumPy vectors, matrix ops, eigenvalues

Day 2 — Calculus for dynamics
- Derivatives as rates of change
- Integrals as accumulation
- ODE intuition
- Python: numerical differentiation & integration

Day 3 — Differential equations
- First-order vs second-order ODEs
- Physical interpretation
- Python: numerical ODE solving

Day 4 — Probability & statistics
- Mean, variance, covariance
- Noise as a feature, not a bug
- Python: sampling, histograms, Gaussian distributions

Day 5 — Discrete time & simulation
- Continuous to discrete systems
- Time steps and numerical stability
- Python: build a minimal simulator loop

After Day 5, Python should feel like a tool, not a hurdle.


PHASE 1: System Modeling (Days 6–12)
------------------------------------

Day 6 — What is a dynamical system?
- State, input, output
- Memory in systems

Day 7 — Physical modeling
- Mass–spring–damper system
- Energy-based intuition

Day 8 — State-space representation
- Why state-space beats transfer functions for robotics

Day 9 — Linearization
- Nonlinear reality
- Local linear truth

Day 10 — Stability
- Eigenvalues as system destiny

Day 11 — Discretization
- Sampling effects
- Aliasing intuition

Day 12 — Modeling errors
- Why models lie
- Parameter uncertainty


PHASE 2: Control (Days 13–22)
-----------------------------

Day 13 — Feedback
Day 14 — Proportional control (P)
Day 15 — Integral and Derivative control (PI / PD)
Day 16 — Full PID control
Day 17 — State feedback
Day 18 — Controllability
Day 19 — Linear Quadratic Regulator (LQR)
Day 20 — Constraints and actuator saturation
Day 21 — Why Model Predictive Control (MPC) exists
Day 22 — Control failure modes

By Day 22, control should feel intuitive, not procedural.


PHASE 3: Estimation & Uncertainty (Days 23–32)
----------------------------------------------

Day 23 — Sensors and noise
Day 24 — Probability for robotics
Day 25 — Bayesian estimation
Day 26 — Kalman filter (scalar case)
Day 27 — Kalman filter (vector case)
Day 28 — Covariance intuition
Day 29 — Extended Kalman Filter (EKF)
Day 30 — When EKF fails
Day 31 — Estimation vs control
Day 32 — Closed-loop estimation

This phase builds comfort with uncertainty.


PHASE 4: Motion, Planning & Geometry (Days 33–42)
-------------------------------------------------

Day 33 — Coordinate frames
Day 34 — Rigid body motion
Day 35 — Robot kinematics
Day 36 — Configuration space
Day 37 — Path vs trajectory
Day 38 — Trajectory generation
Day 39 — Obstacle avoidance
Day 40 — Local vs global planning
Day 41 — Planner–controller mismatch
Day 42 — Planning failure modes


PHASE 5: Perception as a System (Days 43–50)
--------------------------------------------

Day 43 — What perception really is
Day 44 — Measurement models
Day 45 — Cameras and geometry
Day 46 — IMU intuition
Day 47 — Sensor fusion
Day 48 — Perception uncertainty
Day 49 — Active perception
Day 50 — Perception–control loop

No CV magic. Only signals, models, and uncertainty.


PHASE 6: ROS 2 + Real Systems (Theory-First) (Days 51–60)
---------------------------------------------------------

Day 51 — Why ROS exists
Day 52 — Nodes, topics, services (theory only)
Day 53 — Distributed systems intuition
Day 54 — Timing, latency, synchronization
Day 55 — Simulation vs real robots
Day 56 — Safety and fault tolerance
Day 57 — System integration
Day 58 — Debugging complex robotic systems
Day 59 — Designing a full robot stack (on paper)
Day 60 — Capstone systems reflection

Real ROS 2 implementation should only begin after Day 60,
with proper systems understanding in place.

=============================================